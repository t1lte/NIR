{
    "import": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n)\n",
    "package": "package chaincode\n",
    "contract_definition": "type SmartContract struct {\n\tcontractapi.Contract\n}\n",
    "fix_part": "type ElementState int\n\nconst (\n\tDISABLED = iota\n\tENABLED\n\tWAITINGFORCONFIRMATION\n\tCOMPLETED\n)\n\ntype Participant struct {\n\tMSP        string            `json:\"msp\"`\n\tAttributes map[string]string `json:\"attributes\"`\n}\n\ntype Message struct {\n\tMessageID            string       `json:\"messageID\"`\n\tSendParticipantID    string       `json:\"sendParticipantID\"`\n\tReceiveParticipantID string       `json:\"receiveParticipantID\"`\n\tMsgState             ElementState `json:\"msgState\"`\n\tFormat               string       `json:\"format\"`\n}\n\ntype Gateway struct {\n\tGatewayID    string       `json:\"gatewayID\"`\n\tGatewayState ElementState `json:\"gatewayState\"`\n}\n\ntype ActionEvent struct {\n\tEventID    string       `json:\"eventID\"`\n\tEventState ElementState `json:\"eventState\"`\n}\n\nfunc (cc *SmartContract) CreateParticipant(ctx contractapi.TransactionContextInterface, participantID string, msp string, attributes map[string]string) (*Participant, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(participantID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err)\n\t}\n\tif existingData != nil {\n\t\treturn nil, fmt.Errorf(\"Participant %s already exists\", participantID)\n\t}\n\n\t\n\tparticipant := &Participant{\n\t\tMSP:        msp,\n\t\tAttributes: attributes,\n\t}\n\n\t\n\tparticipantJSON, err := json.Marshal(participant)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error serializing participant data: %v\", err)\n\t}\n\terr = stub.PutState(participantID, participantJSON)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error saving participant data: %v\", err)\n\t}\n\n\treturn participant, nil\n}\n\nfunc (cc *SmartContract) CreateMessage(ctx contractapi.TransactionContextInterface, messageID string, sendParticipantID string, receiveParticipantID string, msgState ElementState, format string) (*Message, error) {\n\tstub := ctx.GetStub()\n\n\t\n\texistingData, err := stub.GetState(messageID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err)\n\t}\n\tif existingData != nil {\n\t\treturn nil, fmt.Errorf(\"Message %s already exists\", messageID)\n\t}\n\n\t\n\tmsg := &Message{\n\t\tMessageID:            messageID,\n\t\tSendParticipantID:    sendParticipantID,\n\t\tReceiveParticipantID: receiveParticipantID,\n\t\tMsgState:             msgState,\n\t\tFormat:               format,\n\t}\n\n\t\n\tmsgJSON, err := json.Marshal(msg)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error serializing message data: %v\", err)\n\t}\n\terr = stub.PutState(messageID, msgJSON)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error saving message data: %v\", err)\n\t}\n\n\treturn msg, nil\n}\n\nfunc (cc *SmartContract) CreateGateway(ctx contractapi.TransactionContextInterface, gatewayID string, gatewayState ElementState) (*Gateway, error) {\n\tstub := ctx.GetStub()\n\n\t\n\texistingData, err := stub.GetState(gatewayID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err)\n\t}\n\tif existingData != nil {\n\t\treturn nil, fmt.Errorf(\"Gateway %s already exists\", gatewayID)\n\t}\n\n\t\n\tgtw := &Gateway{\n\t\tGatewayID:    gatewayID,\n\t\tGatewayState: gatewayState,\n\t}\n\n\t\n\tgtwJSON, err := json.Marshal(gtw)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error serializing gateway data: %v\", err)\n\t}\n\terr = stub.PutState(gatewayID, gtwJSON)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error saving gateway data: %v\", err)\n\t}\n\n\treturn gtw, nil\n}\n\nfunc (cc *SmartContract) CreateActionEvent(ctx contractapi.TransactionContextInterface, eventID string, eventState ElementState) (*ActionEvent, error) {\n\tstub := ctx.GetStub()\n\n\t\n\tactionEvent := &ActionEvent{\n\t\tEventID:    eventID,\n\t\tEventState: eventState,\n\t}\n\n\t\n\tactionEventJSON, err := json.Marshal(actionEvent)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error serializing event data: %v\", err)\n\t}\n\terr = stub.PutState(eventID, actionEventJSON)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error saving event data: %v\", err)\n\t}\n\n\treturn actionEvent, nil\n}\n\n\nfunc (c *SmartContract) ReadMsg(ctx contractapi.TransactionContextInterface, messageID string) (*Message, error) {\n\tmsgJSON, err := ctx.GetStub().GetState(messageID)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tif msgJSON == nil {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar msg Message\n\terr = json.Unmarshal(msgJSON, &msg)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &msg, nil\n}\n\nfunc (c *SmartContract) ReadGtw(ctx contractapi.TransactionContextInterface, gatewayID string) (*Gateway, error) {\n\tgtwJSON, err := ctx.GetStub().GetState(gatewayID)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tif gtwJSON == nil {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar gtw Gateway\n\terr = json.Unmarshal(gtwJSON, &gtw)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &gtw, nil\n}\n\nfunc (c *SmartContract) ReadEvent(ctx contractapi.TransactionContextInterface, eventID string) (*ActionEvent, error) {\n\teventJSON, err := ctx.GetStub().GetState(eventID)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tif eventJSON == nil {\n\t\terrorMessage := fmt.Sprintf(\"Event state %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar event ActionEvent\n\terr = json.Unmarshal(eventJSON, &event)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &event, nil\n}\n\n\nfunc (c *SmartContract) ChangeMsgState(ctx contractapi.TransactionContextInterface, messageID string, msgState ElementState) error {\n\tstub := ctx.GetStub()\n\n\tmsg, err := c.ReadMsg(ctx, messageID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmsg.MsgState = msgState\n\n\tmsgJSON, err := json.Marshal(msg)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(messageID, msgJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SmartContract) ChangeGtwState(ctx contractapi.TransactionContextInterface, gatewayID string, gtwState ElementState) error {\n\tstub := ctx.GetStub()\n\n\tgtw, err := c.ReadGtw(ctx, gatewayID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgtw.GatewayState = gtwState\n\n\tgtwJSON, err := json.Marshal(gtw)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(gatewayID, gtwJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SmartContract) ChangeEventState(ctx contractapi.TransactionContextInterface, eventID string, eventState ElementState) error {\n\tstub := ctx.GetStub()\n\n\tactionEvent, err := c.ReadEvent(ctx, eventID)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tactionEvent.EventState = eventState\n\n\tactionEventJSON, err := json.Marshal(actionEvent)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(eventID, actionEventJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n\n\nfunc (cc *SmartContract) GetAllMessages(ctx contractapi.TransactionContextInterface) ([]*Message, error) {\n\tresultsIterator, err := ctx.GetStub().GetStateByRange(\"\", \"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err) \n\t}\n\tdefer resultsIterator.Close()\n\n\tvar messages []*Message\n\tfor resultsIterator.HasNext() {\n\t\tqueryResponse, err := resultsIterator.Next()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error while iterating state data: %v\", err)\n\t\t}\n\n\t\tvar message Message\n\t\terr = json.Unmarshal(queryResponse.Value, &message)\n\t\tif strings.HasPrefix(message.MessageID, \"Message\") {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Error deserializing message data: %v\", err)\n\t\t\t}\n\n\t\t\tmessages = append(messages, &message)\n\t\t}\n\t}\n\n\treturn messages, nil\n}\n\nfunc (cc *SmartContract) GetAllGateways(ctx contractapi.TransactionContextInterface) ([]*Gateway, error) {\n\tresultsIterator, err := ctx.GetStub().GetStateByRange(\"\", \"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err)\n\t}\n\tdefer resultsIterator.Close()\n\n\tvar gateways []*Gateway\n\tfor resultsIterator.HasNext() {\n\t\tqueryResponse, err := resultsIterator.Next()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error while iterating state data: %v\", err)\n\t\t}\n\n\t\tvar gateway Gateway\n\t\terr = json.Unmarshal(queryResponse.Value, &gateway)\n\t\tif strings.HasPrefix(gateway.GatewayID, \"ExclusiveGateway\") ||\n\t\t\tstrings.HasPrefix(gateway.GatewayID, \"EventBasedGateway\") ||\n\t\t\tstrings.HasPrefix(gateway.GatewayID, \"Gateway\") ||\n\t\t\tstrings.HasPrefix(gateway.GatewayID, \"ParallelGateway\") {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Error deserializing gateway data: %v\", err)\n\t\t\t}\n\n\t\t\tgateways = append(gateways, &gateway)\n\t\t}\n\t}\n\n\treturn gateways, nil\n}\n\nfunc (cc *SmartContract) GetAllActionEvents(ctx contractapi.TransactionContextInterface) ([]*ActionEvent, error) {\n\tresultsIterator, err := ctx.GetStub().GetStateByRange(\"\", \"\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Error getting status data: %v\", err)\n\t}\n\tdefer resultsIterator.Close()\n\n\tvar events []*ActionEvent\n\tfor resultsIterator.HasNext() {\n\t\tqueryResponse, err := resultsIterator.Next()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error while iterating state data: %v\", err)\n\t\t}\n\n\t\tvar event ActionEvent\n\t\terr = json.Unmarshal(queryResponse.Value, &event)\n\t\tif strings.HasPrefix(event.EventID, \"StartEvent\") ||\n\t\t\tstrings.HasPrefix(event.EventID, \"Event\") ||\n\t\t\tstrings.HasPrefix(event.EventID, \"EndEvent\") {\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Error deserializing event data: %v\", err)\n\t\t\t}\n\n\t\t\tevents = append(events, &event)\n\t\t}\n\t}\n\n\treturn events, nil\n}\n\nfunc (cc *SmartContract) ReadParticipant(ctx contractapi.TransactionContextInterface, participantID string) (*Participant, error) {\n\tparticipantJSON, err := ctx.GetStub().GetState(participantID)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tif participantJSON == nil {\n\t\terrorMessage := fmt.Sprintf(\"Participant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar participant Participant\n\terr = json.Unmarshal(participantJSON, &participant)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &participant, nil\n}\n\nfunc (cc *SmartContract) check_msp(ctx contractapi.TransactionContextInterface, target_participant string) bool {\n\t\n\ttargetParticipant, err := cc.ReadParticipant(ctx, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mspID == targetParticipant.MSP\n}\n\nfunc (cc *SmartContract) check_attribute(ctx contractapi.TransactionContextInterface, target_participant string, attributeName string) bool {\n\ttargetParticipant, err := cc.ReadParticipant(ctx, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ctx.GetClientIdentity().AssertAttributeValue(attributeName, targetParticipant.Attributes[attributeName]) != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) check_participant(ctx contractapi.TransactionContextInterface, target_participant string) bool {\n\t\n\ttargetParticipant, err := cc.ReadParticipant(ctx, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\t\n\tif targetParticipant.MSP != \"\" && cc.check_msp(ctx, target_participant) == false {\n\t\treturn false\n\t}\n\n\t\n\tfor key, _ := range targetParticipant.Attributes {\n\t\tif cc.check_attribute(ctx, target_participant, key) == false {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n",
    "InitFuncFrame": "func (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\n\t\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}}\n\tif isInitedBytes != nil {{\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n{}\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}}\n",
    "InitStart": "\tcc.CreateActionEvent(ctx, \"{}\", ENABLED)\n",
    "InitEnd": "\tcc.CreateActionEvent(ctx, \"{}\", DISABLED)",
    "InitMessage": "\tcc.CreateMessage(ctx, \"{}\", \"{}\", \"{}\", DISABLED, `{}`)",
    "InitGateway": "\tcc.CreateGateway(ctx, \"{}\", DISABLED)\n",
    "ChangeEventState": "    cc.ChangeEventState(ctx, \"{event}\", {state})",
    "ChangeMsgState": "    cc.ChangeMsgState(ctx, \"{message}\", {state})",
    "ChangeGtwState": "    cc.ChangeGtwState(ctx, \"{gateway}\", {state})",
    "StartEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tactionEvent, err := cc.ReadEvent(ctx, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif actionEvent.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", actionEvent.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, \"{event}\", COMPLETED)\n\tstub.SetEvent(\"{event}\", []byte(\"Contract has been started successfully\"))\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
    "MessageSendFuncFrame": "func (cc *SmartContract) {message}_Send(ctx contractapi.TransactionContextInterface {more_parameters}) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx,msg.SendParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tmsg.MsgState = WAITINGFORCONFIRMATION\n\tmsgJSON, _ := json.Marshal(msg)\n\tstub.PutState(\"{message}\", msgJSON)\n\t{put_more_parameters}\n\tstub.SetEvent(\"{message}\", []byte(\"Message is waiting for confirmation\"))\n\n\t{after_all_hook}\n\treturn nil\n}}",
    "MessageCompleteFuncFrame": "func (cc *SmartContract) {message}_Complete(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx,msg.ReceiveParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.ReceiveParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != WAITINGFORCONFIRMATION {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgState(ctx, \"{message}\", COMPLETED)\n\tstub.SetEvent(\"{message}\", []byte(\"Message has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\n\t{after_all_hook}\n\treturn nil\n}}",
    "EndEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tevent, err := cc.ReadEvent(ctx, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif event.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", event.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, \"{event}\", COMPLETED)\n\tstub.SetEvent(\"{event}\", []byte(\"EndEvent has been done\"))\n\t{after_all_hook}\n\treturn nil\n}}",
    "ParallelGatewaySplitFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, \"{parallel_gateway}\", ENABLED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\n{change_next_state_code}\n\n\treturn nil\n}}",
    "ParallelGatewayMergeFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, \"ChoreographyTask_00bnkwc\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, \"{parallel_gateway}\", COMPLETED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
    "EventBasedGatewayFuncFrame": "func (cc *SmartContract) {event_based_gateway}(ctx contractapi.TransactionContextInterface) error {{ \n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, \"{event_based_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, \"{event_based_gateway}\", COMPLETED)\n\tstub.SetEvent(\"{event_based_gateway}\", []byte(\"EventbasedGateway has been done\"))\n\n {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n    return nil\n}}",
    "ExclusiveGatewaySplitFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, \"{exclusive_gateway}\", COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
    "ExclusiveGatewayMergeFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, \"{exclusive_gateway}\", COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
    "CheckMessageState": "func() bool {{ msg, err := cc.ReadMsg(ctx, \"{message}\"); return err == nil && msg.MsgState == {state} }}()",
    "CheckGtwState": "func() bool {{ gtw, err := cc.ReadGtw(ctx, \"{gateway}\"); return err == nil && gtw.GatewayState == {state} }}()",
    "CheckEventState": "func() bool {{ event, err := cc.ReadEvent(ctx, \"{event}\"); return err == nil && event.EventState == {state} }}()",
    "ConditionToDo": "if {condition} {{\n\t{todo}\n}}",
    "StateMemoryDefinitionFrame": "type StateMemory struct {{\n    {}\n}}",
    "StateReadAndSetFunc": "func (cc *SmartContract) ReadState(ctx contractapi.TransactionContextInterface) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) PutState(ctx contractapi.TransactionContextInterface, stateName string, stateValue interface{}) error {\n\tstub := ctx.GetStub()\n\tcurrentMemory, err := cc.ReadState(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tval := reflect.ValueOf(currentMemory)\n\tif val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {\n\t\treturn errors.New(\"currentMemory is not a struct pointer\")\n\t}\n\tfield := val.Elem().FieldByName(stateName)\n\tif !field.IsValid() {\n\t\treturn errors.New(\"field does not exist\")\n\t}\n\tif !field.CanSet() {\n\t\treturn errors.New(\"field cannot be set\")\n\t}\n\t\n\tswitch field.Interface().(type) {\n\tcase string:\n\t\tstringValue, ok := stateValue.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a string\")\n\t\t}\n\t\tfield.SetString(stringValue)\n\tcase int:\n\t\tintValue, ok := stateValue.(int)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not an int\")\n\t\t}\n\t\tfield.SetInt(int64(intValue))\n\tcase float64:\n\t\tfloatValue, ok := stateValue.(float64)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a float64\")\n\t\t}\n\t\tfield.SetFloat(floatValue)\n\tcase bool:\n\t\tboolValue, ok := stateValue.(bool)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a bool\")\n\t\t}\n\t\tfield.SetBool(boolValue)\n\t\n\tdefault:\n\t\treturn errors.New(\"unsupported field type\")\n\t}\n\n\tcurrentMemoryJSON, err := json.Marshal(currentMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(\"currentMemory\", currentMemoryJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}",
    "PutStateFuncFrame": "    cc.PutState(ctx, \"{name}\", {value})",
    "ReadStateFuncFrame": "    {stateName}:=currentMemory.{stateName}\n",
    "ReadCurrentMemoryCode": "    currentMemory,err := cc.ReadState(ctx)\n    if err != nil {\n        return err\n    }\n",
    "ReadAndSetGloablVariable": "func (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\t\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, globalVariable *StateMemory) error {\n\tstub := ctx.GetStub()\n\tglobaleMemoryJson, err := json.Marshal(globalVariable)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\terr = stub.PutState(\"currentMemory\", globaleMemoryJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\treturn nil\n}",
    "SetGlobalVariableFuncFrame": "\tglobalMemory,readGlobalError := cc.ReadGlobalVariable(ctx)\n\tif readGlobalError != nil {{\n\t\tfmt.Println(readGlobalError.Error())\n\t\treturn readGlobalError\n\t}}\n\tglobalMemory.{name} = {value}\n\tsetGlobalError :=cc.SetGlobalVariable(ctx, globalMemory)\n\tif setGlobalError != nil {{\n\t\tfmt.Println(setGlobalError.Error())\n\t\treturn setGlobalError\n\t}}",
    "ReadGlobalVariable": "\tcurrentMemory, err := cc.ReadGlobalVariable(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n",
    "InitParticipant": "\tcc.CreateParticipant(ctx, \"{participant_id}\", \"{participant_msp}\", map[string]string{{{participant_attrs}}})"
}